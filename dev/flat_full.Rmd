---
title: "flat_full.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
library(magrittr)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

# Include some data examples in your package

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->

```{r development-2}
# Run all this chunk in the console directly
# Create "inst/" directory
dir.create(here::here("inst"))

# Example dataset
#file.copy(system.file("nyc_squirrels_sample.csv", package = "fusen"), here::here("inst"))

# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
datafile <- system.file("toy_evyth.rds", package = "comunicacion")
toy_evyth <- readRDS(datafile)

toy_evyth
```


# Función dnmye_colores
<!--
Creo función
-->

```{r function-dnmye_colores}
#' Función para extraer colores de la dnmye como colores hex
#'
#' @param ... Nombre del color
#' @return
#' Paleta de colores institucionales para la República de Argentina
#' @export
#'
#' @examples

### Funcion
dnmye_colores <- function(...) {
  
  ### Lista de colores de la dnmye
colores <- c(
  `rojo`         = "#EE3D8F",
  `naranja`      = "#F7941E",
  `amarillo`     = "#FFD100",
  `verde claro`  = "#D7DF23",
  `verde oscuro` = "#50B8B1",
  `violeta`      = "#9283BE",
  `celeste`      = "#37BBED",
  `gris oscuro`  = "#50535C",
  `gris medio`   = "#AAAAAA",
  `gris claro`   = "#E7E7E7")
  
  cols <- c(...)
  
  if (is.null(cols)) {
    return(unname(colores))
  }
  
  if (!is.null(cols) & is.character(cols)) {
    assertthat::assert_that(cols %in% c(names(colores)), 
                            msg = glue::glue("el valor debe encontrarse entre las siguientes opciones: {paste0(names(dnmye_colores), collapse = ', ')}"))
    
    return(unname(colores[cols]))
  }
  
  if (!is.null(cols) & is.numeric(cols)){
    
    assertthat::assert_that(unique(cols) %in% c(1:10), 
                            msg = glue::glue("Los valores numéricos van de 1 a {length(dnmye_colores)}"))
    
    return(unname(colores[cols]))
  }
}
```



<!--
Creo ejemplos ed uso
-->

```{r examples-colores}
dnmye_colores()

dnmye_colores("rojo")

dnmye_colores(1)
```

<!--
Creo testeos de resultados
-->

```{r tests-dnmye_colores}
test_that("Nombre de los valores numéricos usados en dnmye_colores", {
  expect_true(dnmye_colores(1) == "#EE3D8F")
  expect_true(dnmye_colores(2) == "#F7941E")
  expect_true(dnmye_colores(3) == "#FFD100")
  expect_true(dnmye_colores(4) == "#D7DF23")
  expect_true(dnmye_colores(5) == "#50B8B1")
  expect_true(dnmye_colores(6) == "#9283BE")
  expect_true(dnmye_colores(7) == "#37BBED")
  expect_true(dnmye_colores(8) == "#50535C")
  expect_true(dnmye_colores(9) == "#AAAAAA")
  expect_true(dnmye_colores(10) == "#E7E7E7")
  })


test_that("Nombre de los valores de texto usados en dnmye_colores", {
  expect_true(dnmye_colores("rojo") == "#EE3D8F")
  expect_true(dnmye_colores("naranja") == "#F7941E")
  expect_true(dnmye_colores("amarillo") == "#FFD100")
  expect_true(dnmye_colores("verde claro") == "#D7DF23")
  expect_true(dnmye_colores("verde oscuro") == "#50B8B1")
  expect_true(dnmye_colores("violeta") == "#9283BE")
  expect_true(dnmye_colores("celeste") == "#37BBED")
  expect_true(dnmye_colores("gris oscuro") == "#50535C")
  expect_true(dnmye_colores("gris medio") == "#AAAAAA")
  expect_true(dnmye_colores("gris claro") == "#E7E7E7")
  })
```


<!--
Creo Función
-->

```{r function-dnmye_paletas}
#' Función para extraer colores de la dnmye como colores hex
#'
#' @param palette Nombre de la paleta de colores en dnmye_paletas. Se puede optar por *c2_continuo*, *c2_contraste* o *c10_todos*
#' @param reverse *TRUE* indica que la peleta debe ser invertida
#' @param ... Argumentos adicionales para definir con colorRampPalette()
#' @return
#' Paleta de colores institucionales para la República de Argentina
#' @export
#'
#' @examples

### Funcion
dnmye_paletas <- function(palette = "c10_todos", reverse = FALSE, ...) {
  
  ### Paleta de colores
paletas <- list(
  
  `c2_continuo`  = c("#50B8B1", "#9283BE"),
  `c2_contraste` = c("#50B8B1", "#EE3D8F"),
  `c10_todos`     = c("#EE3D8F", "#F7941E", "#FFD100", "#D7DF23", "#50B8B1",
                      "#9283BE", "#37BBED", "#50535C", "#AAAAAA", "#E7E7E7"))

  pal <- paletas[[palette]]

  if (reverse) pal <- rev(pal)

  grDevices::colorRampPalette(pal, ...)
}
```



<!--
Creo ejemplos de uso
-->

```{r examples-dnmye_paletas}
dnmye_paletas("c2_continuo")(3)
dnmye_paletas("c10_todos")(20)
```

<!--
Creo testeo de resultados
-->



<!--
Creo función
-->

```{r function-scale_color_dnmye}
#' Constructor de escala de colores de contorno (color) para la dnmye
#'
#' @param palette Nombre de la paleta de colores en dnmye_paleta
#' @param discrete TRUE indica que la variable es discreta
#' @param reverse *TRUE* indica que la peleta debe ser invertida
#' @param ... Argumentos adicionales para definir en discrete_scale() o
#'            scale_color_gradientn(), respectivamente, cuando discrete es TRUE o FALSE
#' @export
#'
#' @examples

### Funcion
scale_colour_dnmye <- function(palette = "c10_todos", discrete = TRUE, reverse = FALSE, ...) {
  
  pal <- dnmye_paletas(palette = palette, reverse = reverse)

  if (discrete) {
    ggplot2::discrete_scale("colour", paste0("dnmye_", palette), palette = pal, ...)
  } else {
    ggplot2::scale_color_gradientn(colours = pal(256), ...)
  }
}
```


<!--
Creo ejemplos de uso
-->

```{r examples-scale_color_dnmye}
datafile <- system.file("toy_evyth.rds", package = "comunicacion")
toy_evyth <- readRDS(datafile)

toy_evyth %>% 
  dplyr::mutate(periodo = as.factor(paste0(anio, trimestre)),
                region_destino = factor(region_destino, 
                                        labels = c("Ciudad de Buenos Aires", 
                                                   "Provincia de Buenos Aires - Partidos del GBA",
                                                   "Provincia de Buenos Aires - Resto", "Centro", 
                                                   "Litoral", 
                                                   "Norte", "Cuyo", "Patagonia"))) %>% 
  dplyr::group_by(periodo, region_destino) %>% 
  dplyr::summarise(cantidad_personas = sum(pondera)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = periodo, 
                               y = cantidad_personas, 
                               colour = region_destino, 
                               group = region_destino)) +
  ggplot2::geom_line() +
  scale_colour_dnmye()
```

<!--
Creo testeos de resultados
-->



<!--
Creo función 
-->

```{r function-scale_fill_dnmye}
#' Constructor de escala de colores de contorno (color) para la dnmye
#'
#' @param palette Nombre de la paleta de colores en dnmye_paleta
#' @param discrete TRUE indica que la variable es discreta
#' @param reverse *TRUE* indica que la peleta debe ser invertida
#' @param ... Argumentos adicionales para definir en discrete_scale() o
#'            scale_color_gradientn(), respectivamente, cuando discrete es TRUE o FALSE
#' @export
#'
#' @examples

### Funcion
scale_fill_dnmye <- function(palette = "c10_todos", discrete = TRUE, reverse = FALSE, ...) {
  
  pal <- dnmye_paletas(palette = palette, reverse = reverse)

  if (discrete) {
    ggplot2::discrete_scale("fill", paste0("dnmye_", palette), palette = pal, ...)
  } else {
    ggplot2::scale_fill_gradientn(colours = pal(256), ...)
  }
}
```


<!--
Creo ejemplos de uso
-->

```{r examples-scale_fill_dnmye}
datafile <- system.file("toy_evyth.rds", package = "comunicacion")
toy_evyth <- readRDS(datafile)

toy_evyth %>% 
  dplyr::mutate(region_destino = factor(region_destino, 
                                        labels = c("Ciudad de Buenos Aires", 
                                                   "Provincia de Buenos Aires - Partidos del GBA",
                                                   "Provincia de Buenos Aires - Resto", "Centro", 
                                                   "Litoral", 
                                                   "Norte", "Cuyo", "Patagonia"))) %>% 
  dplyr::group_by(anio, region_destino) %>% 
  dplyr::summarise(cantidad_personas = sum(pondera)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = anio, 
                               y = cantidad_personas, 
                               fill = region_destino)) +
  ggplot2::geom_col(position = ggplot2::position_dodge()) +
  scale_fill_dnmye()
```

<!--
Creo testeos de resultados
-->

<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_full.Rmd", vignette_name = "Get started", )
```


# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()`

- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory
